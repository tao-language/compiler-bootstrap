module TaoPrecedenceTests where

import Parser (State (..))
import Tao
import Test.Hspec

run :: SpecWith ()
run = describe "--== Tao precedence ==--" $ do
  let (a, b, c) = (Var "a", Var "b", Var "c")
  let (x, y, z) = (Var "x", Var "y", Var "z")

  let prec' :: String -> Either String (Expr, String)
      prec' src = case parse "<TaoPrecedence>" src of
        Right (a, s) | s.remaining /= "" -> Right (dropMeta a, "remaining: " ++ s.remaining)
        Right (a, _) -> Right (dropMeta a, format 80 (dropMeta a))
        Left s -> Left ("syntax error, remaining: " ++ s.remaining)
  let prec :: String -> Either (Expr, String) Expr
      prec src = case prec' src of
        Right (a, out) | src == out -> Right a
        Right (a, out) -> Left (a, out)
        Left err -> Left (Any, err)

  it "☯ TaoPrecedence.Let" $ do
    prec "let x = let y = z\na\nb" `shouldBe` Right (Let (x, Let (y, z) a) b)
    prec "let x = y | z\na" `shouldBe` Right (Let (x, y `Or` z) a)
    prec "let x = y or z\na" `shouldBe` Right (Let (x, y `orOp` z) a)
    prec "let x = y xor z\na" `shouldBe` Right (Let (x, y `xorOp` z) a)
    prec "let x = y and z\na" `shouldBe` Right (Let (x, y `andOp` z) a)
    prec "let x = y == z\na" `shouldBe` Right (Let (x, y `eq` z) a)
    prec "let x = y != z\na" `shouldBe` Right (Let (x, y `ne` z) a)
    prec "let x = y < z\na" `shouldBe` Right (Let (x, y `lt` z) a)
    prec "let x = y <= z\na" `shouldBe` Right (Let (x, y `le` z) a)
    prec "let x = y > z\na" `shouldBe` Right (Let (x, y `gt` z) a)
    prec "let x = y >= z\na" `shouldBe` Right (Let (x, y `ge` z) a)
    prec "let x = y :: z\na" `shouldBe` Right (Let (x, y `cons` z) a)
    prec "let x = y : z\na" `shouldBe` Right (Let (x, y `Ann` z) a)
    prec "let x = y -> z\na" `shouldBe` Right (Let (x, y `Fun` z) a)
    prec "let x = @y. z\na" `shouldBe` Right (Let (x, For ["y"] z) a)
    prec "let x = y + z\na" `shouldBe` Right (Let (x, y `add` z) a)
    prec "let x = y - z\na" `shouldBe` Right (Let (x, y `sub` z) a)
    prec "let x = y * z\na" `shouldBe` Right (Let (x, y `mul` z) a)
    prec "let x = y / z\na" `shouldBe` Right (Let (x, y `div'` z) a)
    prec "let x = y // z\na" `shouldBe` Right (Let (x, y `div2` z) a)
    prec "let x = y ^ z\na" `shouldBe` Right (Let (x, y `pow` z) a)
    prec "let x = -y\na" `shouldBe` Right (Let (x, neg y) a)
    prec "let x = y(z)\na" `shouldBe` Right (Let (x, y `app1` z) a)

  -- it "☯ TaoPrecedence.Bind" $ do

  it "☯ TaoPrecedence.Or" $ do
    prec "x | y | z" `shouldBe` Right (x `Or` (y `Or` z))
    prec "x | y or z" `shouldBe` Right (x `Or` (y `orOp` z))
    prec "x | y xor z" `shouldBe` Right (x `Or` (y `xorOp` z))
    prec "x | y and z" `shouldBe` Right (x `Or` (y `andOp` z))
    prec "x | y == z" `shouldBe` Right (x `Or` (y `eq` z))
    prec "x | y != z" `shouldBe` Right (x `Or` (y `ne` z))
    prec "x | y < z" `shouldBe` Right (x `Or` (y `lt` z))
    prec "x | y <= z" `shouldBe` Right (x `Or` (y `le` z))
    prec "x | y > z" `shouldBe` Right (x `Or` (y `gt` z))
    prec "x | y >= z" `shouldBe` Right (x `Or` (y `ge` z))
    prec "x | y :: z" `shouldBe` Right (x `Or` (y `cons` z))
    prec "x | y : z" `shouldBe` Right (x `Or` (y `Ann` z))
    prec "x | y -> z" `shouldBe` Right (x `Or` (y `Fun` z))
    prec "x | @y. z" `shouldBe` Right (x `Or` For ["y"] z)
    prec "x | y + z" `shouldBe` Right (x `Or` (y `add` z))
    prec "x | y - z" `shouldBe` Right (x `Or` (y `sub` z))
    prec "x | y * z" `shouldBe` Right (x `Or` (y `mul` z))
    prec "x | y / z" `shouldBe` Right (x `Or` (y `div'` z))
    prec "x | y // z" `shouldBe` Right (x `Or` (y `div2` z))
    prec "x | y ^ z" `shouldBe` Right (x `Or` (y `pow` z))
    prec "x | -y" `shouldBe` Right (x `Or` neg y)
    prec "x | y(z)" `shouldBe` Right (x `Or` (y `app1` z))

  it "☯ TaoPrecedence.If" $ do
    let w = Var "w"
    prec "x if y | z -> w" `shouldBe` Right (x `If` y `Or` (z `Fun` w))
    prec "x if y -> z -> w" `shouldBe` Right (x `If` y `Fun` (z `Fun` w))
    prec "x if y or z -> w" `shouldBe` Right (x `If` (y `orOp` z) `Fun` w)
    prec "x if y xor z -> w" `shouldBe` Right (x `If` (y `xorOp` z) `Fun` w)
    prec "x if y and z -> w" `shouldBe` Right (x `If` (y `andOp` z) `Fun` w)
    prec "x if y == z -> w" `shouldBe` Right (x `If` (y `eq` z) `Fun` w)
    prec "x if y != z -> w" `shouldBe` Right (x `If` (y `ne` z) `Fun` w)
    prec "x if y < z -> w" `shouldBe` Right (x `If` (y `lt` z) `Fun` w)
    prec "x if y <= z -> w" `shouldBe` Right (x `If` (y `le` z) `Fun` w)
    prec "x if y > z -> w" `shouldBe` Right (x `If` (y `gt` z) `Fun` w)
    prec "x if y >= z -> w" `shouldBe` Right (x `If` (y `ge` z) `Fun` w)
    prec "x if y :: z -> w" `shouldBe` Right (x `If` (y `cons` z) `Fun` w)
    prec "x if y : z -> w" `shouldBe` Right (x `If` (y `Ann` z) `Fun` w)
    prec "x if @y. z -> w" `shouldBe` Right (x `If` For ["y"] z `Fun` w)
    prec "x if y + z -> w" `shouldBe` Right (x `If` (y `add` z) `Fun` w)
    prec "x if y - z -> w" `shouldBe` Right (x `If` (y `sub` z) `Fun` w)
    prec "x if y * z -> w" `shouldBe` Right (x `If` (y `mul` z) `Fun` w)
    prec "x if y / z -> w" `shouldBe` Right (x `If` (y `div'` z) `Fun` w)
    prec "x if y // z -> w" `shouldBe` Right (x `If` (y `div2` z) `Fun` w)
    prec "x if y ^ z -> w" `shouldBe` Right (x `If` (y `pow` z) `Fun` w)
    prec "x if -y -> w" `shouldBe` Right (x `If` neg y `Fun` w)
    prec "x if y(z) -> w" `shouldBe` Right (x `If` (y `app1` z) `Fun` w)

  it "☯ TaoPrecedence.Op2.And" $ do
    prec "x and y | z" `shouldBe` Right ((x `andOp` y) `Or` z)
    prec "x and y or z" `shouldBe` Right ((x `andOp` y) `orOp` z)
    prec "x and y xor z" `shouldBe` Right ((x `andOp` y) `xorOp` z)
    prec "x and y and z" `shouldBe` Right ((x `andOp` y) `andOp` z)
    prec "x and y == z" `shouldBe` Right (x `andOp` (y `eq` z))
    prec "x and y != z" `shouldBe` Right (x `andOp` (y `ne` z))
    prec "x and y < z" `shouldBe` Right (x `andOp` (y `lt` z))
    prec "x and y <= z" `shouldBe` Right (x `andOp` (y `le` z))
    prec "x and y > z" `shouldBe` Right (x `andOp` (y `gt` z))
    prec "x and y >= z" `shouldBe` Right (x `andOp` (y `ge` z))
    prec "x and y :: z" `shouldBe` Right (x `andOp` (y `cons` z))
    prec "x and y : z" `shouldBe` Right (x `andOp` (y `Ann` z))
    prec "x and y -> z" `shouldBe` Right (x `andOp` (y `Fun` z))
    prec "x and @y. z" `shouldBe` Right (x `andOp` For ["y"] z)
    prec "x and y + z" `shouldBe` Right (x `andOp` (y `add` z))
    prec "x and y - z" `shouldBe` Right (x `andOp` (y `sub` z))
    prec "x and y * z" `shouldBe` Right (x `andOp` (y `mul` z))
    prec "x and y / z" `shouldBe` Right (x `andOp` (y `div'` z))
    prec "x and y // z" `shouldBe` Right (x `andOp` (y `div2` z))
    prec "x and y ^ z" `shouldBe` Right (x `andOp` (y `pow` z))
    prec "x and -y" `shouldBe` Right (x `andOp` neg y)
    prec "x and y(z)" `shouldBe` Right (x `andOp` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Or" $ do
    prec "x or y | z" `shouldBe` Right ((x `orOp` y) `Or` z)
    prec "x or y or z" `shouldBe` Right ((x `orOp` y) `orOp` z)
    prec "x or y xor z" `shouldBe` Right ((x `orOp` y) `xorOp` z)
    prec "x or y and z" `shouldBe` Right (x `orOp` (y `andOp` z))
    prec "x or y == z" `shouldBe` Right (x `orOp` (y `eq` z))
    prec "x or y != z" `shouldBe` Right (x `orOp` (y `ne` z))
    prec "x or y < z" `shouldBe` Right (x `orOp` (y `lt` z))
    prec "x or y <= z" `shouldBe` Right (x `orOp` (y `le` z))
    prec "x or y > z" `shouldBe` Right (x `orOp` (y `gt` z))
    prec "x or y >= z" `shouldBe` Right (x `orOp` (y `ge` z))
    prec "x or y :: z" `shouldBe` Right (x `orOp` (y `cons` z))
    prec "x or y : z" `shouldBe` Right (x `orOp` (y `Ann` z))
    prec "x or y -> z" `shouldBe` Right (x `orOp` (y `Fun` z))
    prec "x or @y. z" `shouldBe` Right (x `orOp` For ["y"] z)
    prec "x or y + z" `shouldBe` Right (x `orOp` (y `add` z))
    prec "x or y - z" `shouldBe` Right (x `orOp` (y `sub` z))
    prec "x or y * z" `shouldBe` Right (x `orOp` (y `mul` z))
    prec "x or y / z" `shouldBe` Right (x `orOp` (y `div'` z))
    prec "x or y // z" `shouldBe` Right (x `orOp` (y `div2` z))
    prec "x or y ^ z" `shouldBe` Right (x `orOp` (y `pow` z))
    prec "x or -y" `shouldBe` Right (x `orOp` neg y)
    prec "x or y(z)" `shouldBe` Right (x `orOp` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Xor" $ do
    prec "x xor y | z" `shouldBe` Right ((x `xorOp` y) `Or` z)
    prec "x xor y or z" `shouldBe` Right ((x `xorOp` y) `orOp` z)
    prec "x xor y xor z" `shouldBe` Right ((x `xorOp` y) `xorOp` z)
    prec "x xor y and z" `shouldBe` Right (x `xorOp` (y `andOp` z))
    prec "x xor y == z" `shouldBe` Right (x `xorOp` (y `eq` z))
    prec "x xor y != z" `shouldBe` Right (x `xorOp` (y `ne` z))
    prec "x xor y < z" `shouldBe` Right (x `xorOp` (y `lt` z))
    prec "x xor y <= z" `shouldBe` Right (x `xorOp` (y `le` z))
    prec "x xor y > z" `shouldBe` Right (x `xorOp` (y `gt` z))
    prec "x xor y >= z" `shouldBe` Right (x `xorOp` (y `ge` z))
    prec "x xor y :: z" `shouldBe` Right (x `xorOp` (y `cons` z))
    prec "x xor y : z" `shouldBe` Right (x `xorOp` (y `Ann` z))
    prec "x xor y -> z" `shouldBe` Right (x `xorOp` (y `Fun` z))
    prec "x xor @y. z" `shouldBe` Right (x `xorOp` For ["y"] z)
    prec "x xor y + z" `shouldBe` Right (x `xorOp` (y `add` z))
    prec "x xor y - z" `shouldBe` Right (x `xorOp` (y `sub` z))
    prec "x xor y * z" `shouldBe` Right (x `xorOp` (y `mul` z))
    prec "x xor y / z" `shouldBe` Right (x `xorOp` (y `div'` z))
    prec "x xor y // z" `shouldBe` Right (x `xorOp` (y `div2` z))
    prec "x xor y ^ z" `shouldBe` Right (x `xorOp` (y `pow` z))
    prec "x xor -y" `shouldBe` Right (x `xorOp` neg y)
    prec "x xor y(z)" `shouldBe` Right (x `xorOp` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Eq" $ do
    prec "x == y | z" `shouldBe` Right ((x `eq` y) `Or` z)
    prec "x == y or z" `shouldBe` Right ((x `eq` y) `orOp` z)
    prec "x == y xor z" `shouldBe` Right ((x `eq` y) `xorOp` z)
    prec "x == y and z" `shouldBe` Right ((x `eq` y) `andOp` z)
    prec "x == y == z" `shouldBe` Right ((x `eq` y) `eq` z)
    prec "x == y != z" `shouldBe` Right ((x `eq` y) `ne` z)
    prec "x == y < z" `shouldBe` Right (x `eq` (y `lt` z))
    prec "x == y <= z" `shouldBe` Right (x `eq` (y `le` z))
    prec "x == y > z" `shouldBe` Right (x `eq` (y `gt` z))
    prec "x == y >= z" `shouldBe` Right (x `eq` (y `ge` z))
    prec "x == y :: z" `shouldBe` Right (x `eq` (y `cons` z))
    prec "x == y : z" `shouldBe` Right (x `eq` (y `Ann` z))
    prec "x == y -> z" `shouldBe` Right (x `eq` (y `Fun` z))
    prec "x == @y. z" `shouldBe` Right (x `eq` For ["y"] z)
    prec "x == y + z" `shouldBe` Right (x `eq` (y `add` z))
    prec "x == y - z" `shouldBe` Right (x `eq` (y `sub` z))
    prec "x == y * z" `shouldBe` Right (x `eq` (y `mul` z))
    prec "x == y / z" `shouldBe` Right (x `eq` (y `div'` z))
    prec "x == y // z" `shouldBe` Right (x `eq` (y `div2` z))
    prec "x == y ^ z" `shouldBe` Right (x `eq` (y `pow` z))
    prec "x == -y" `shouldBe` Right (x `eq` neg y)
    prec "x == y(z)" `shouldBe` Right (x `eq` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Ne" $ do
    prec "x != y | z" `shouldBe` Right ((x `ne` y) `Or` z)
    prec "x != y or z" `shouldBe` Right ((x `ne` y) `orOp` z)
    prec "x != y xor z" `shouldBe` Right ((x `ne` y) `xorOp` z)
    prec "x != y and z" `shouldBe` Right ((x `ne` y) `andOp` z)
    prec "x != y == z" `shouldBe` Right ((x `ne` y) `eq` z)
    prec "x != y != z" `shouldBe` Right ((x `ne` y) `ne` z)
    prec "x != y < z" `shouldBe` Right (x `ne` (y `lt` z))
    prec "x != y <= z" `shouldBe` Right (x `ne` (y `le` z))
    prec "x != y > z" `shouldBe` Right (x `ne` (y `gt` z))
    prec "x != y >= z" `shouldBe` Right (x `ne` (y `ge` z))
    prec "x != y :: z" `shouldBe` Right (x `ne` (y `cons` z))
    prec "x != y : z" `shouldBe` Right (x `ne` (y `Ann` z))
    prec "x != y -> z" `shouldBe` Right (x `ne` (y `Fun` z))
    prec "x != @y. z" `shouldBe` Right (x `ne` For ["y"] z)
    prec "x != y + z" `shouldBe` Right (x `ne` (y `add` z))
    prec "x != y - z" `shouldBe` Right (x `ne` (y `sub` z))
    prec "x != y * z" `shouldBe` Right (x `ne` (y `mul` z))
    prec "x != y / z" `shouldBe` Right (x `ne` (y `div'` z))
    prec "x != y // z" `shouldBe` Right (x `ne` (y `div2` z))
    prec "x != y ^ z" `shouldBe` Right (x `ne` (y `pow` z))
    prec "x != -y" `shouldBe` Right (x `ne` neg y)
    prec "x != y(z)" `shouldBe` Right (x `ne` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Lt" $ do
    prec "x < y | z" `shouldBe` Right ((x `lt` y) `Or` z)
    prec "x < y or z" `shouldBe` Right ((x `lt` y) `orOp` z)
    prec "x < y xor z" `shouldBe` Right ((x `lt` y) `xorOp` z)
    prec "x < y and z" `shouldBe` Right ((x `lt` y) `andOp` z)
    prec "x < y == z" `shouldBe` Right ((x `lt` y) `eq` z)
    prec "x < y != z" `shouldBe` Right ((x `lt` y) `ne` z)
    prec "x < y < z" `shouldBe` Right ((x `lt` y) `lt` z)
    prec "x < y <= z" `shouldBe` Right ((x `lt` y) `le` z)
    prec "x < y > z" `shouldBe` Right ((x `lt` y) `gt` z)
    prec "x < y >= z" `shouldBe` Right ((x `lt` y) `ge` z)
    prec "x < y :: z" `shouldBe` Right (x `lt` (y `cons` z))
    prec "x < y : z" `shouldBe` Right (x `lt` (y `Ann` z))
    prec "x < y -> z" `shouldBe` Right (x `lt` (y `Fun` z))
    prec "x < @y. z" `shouldBe` Right (x `lt` For ["y"] z)
    prec "x < y + z" `shouldBe` Right (x `lt` (y `add` z))
    prec "x < y - z" `shouldBe` Right (x `lt` (y `sub` z))
    prec "x < y * z" `shouldBe` Right (x `lt` (y `mul` z))
    prec "x < y / z" `shouldBe` Right (x `lt` (y `div'` z))
    prec "x < y // z" `shouldBe` Right (x `lt` (y `div2` z))
    prec "x < y ^ z" `shouldBe` Right (x `lt` (y `pow` z))
    prec "x < -y" `shouldBe` Right (x `lt` neg y)
    prec "x < y(z)" `shouldBe` Right (x `lt` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Le" $ do
    prec "x <= y | z" `shouldBe` Right ((x `le` y) `Or` z)
    prec "x <= y or z" `shouldBe` Right ((x `le` y) `orOp` z)
    prec "x <= y xor z" `shouldBe` Right ((x `le` y) `xorOp` z)
    prec "x <= y and z" `shouldBe` Right ((x `le` y) `andOp` z)
    prec "x <= y == z" `shouldBe` Right ((x `le` y) `eq` z)
    prec "x <= y != z" `shouldBe` Right ((x `le` y) `ne` z)
    prec "x <= y < z" `shouldBe` Right ((x `le` y) `lt` z)
    prec "x <= y <= z" `shouldBe` Right ((x `le` y) `le` z)
    prec "x <= y > z" `shouldBe` Right ((x `le` y) `gt` z)
    prec "x <= y >= z" `shouldBe` Right ((x `le` y) `ge` z)
    prec "x <= y :: z" `shouldBe` Right (x `le` (y `cons` z))
    prec "x <= y : z" `shouldBe` Right (x `le` (y `Ann` z))
    prec "x <= y -> z" `shouldBe` Right (x `le` (y `Fun` z))
    prec "x <= @y. z" `shouldBe` Right (x `le` For ["y"] z)
    prec "x <= y + z" `shouldBe` Right (x `le` (y `add` z))
    prec "x <= y - z" `shouldBe` Right (x `le` (y `sub` z))
    prec "x <= y * z" `shouldBe` Right (x `le` (y `mul` z))
    prec "x <= y / z" `shouldBe` Right (x `le` (y `div'` z))
    prec "x <= y // z" `shouldBe` Right (x `le` (y `div2` z))
    prec "x <= y ^ z" `shouldBe` Right (x `le` (y `pow` z))
    prec "x <= -y" `shouldBe` Right (x `le` neg y)
    prec "x <= y(z)" `shouldBe` Right (x `le` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Gt" $ do
    prec "x > y | z" `shouldBe` Right ((x `gt` y) `Or` z)
    prec "x > y or z" `shouldBe` Right ((x `gt` y) `orOp` z)
    prec "x > y xor z" `shouldBe` Right ((x `gt` y) `xorOp` z)
    prec "x > y and z" `shouldBe` Right ((x `gt` y) `andOp` z)
    prec "x > y == z" `shouldBe` Right ((x `gt` y) `eq` z)
    prec "x > y != z" `shouldBe` Right ((x `gt` y) `ne` z)
    prec "x > y < z" `shouldBe` Right ((x `gt` y) `lt` z)
    prec "x > y <= z" `shouldBe` Right ((x `gt` y) `le` z)
    prec "x > y > z" `shouldBe` Right ((x `gt` y) `gt` z)
    prec "x > y >= z" `shouldBe` Right ((x `gt` y) `ge` z)
    prec "x > y :: z" `shouldBe` Right (x `gt` (y `cons` z))
    prec "x > y : z" `shouldBe` Right (x `gt` (y `Ann` z))
    prec "x > y -> z" `shouldBe` Right (x `gt` (y `Fun` z))
    prec "x > @y. z" `shouldBe` Right (x `gt` For ["y"] z)
    prec "x > y + z" `shouldBe` Right (x `gt` (y `add` z))
    prec "x > y - z" `shouldBe` Right (x `gt` (y `sub` z))
    prec "x > y * z" `shouldBe` Right (x `gt` (y `mul` z))
    prec "x > y / z" `shouldBe` Right (x `gt` (y `div'` z))
    prec "x > y // z" `shouldBe` Right (x `gt` (y `div2` z))
    prec "x > y ^ z" `shouldBe` Right (x `gt` (y `pow` z))
    prec "x > -y" `shouldBe` Right (x `gt` neg y)
    prec "x > y(z)" `shouldBe` Right (x `gt` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Ge" $ do
    prec "x >= y | z" `shouldBe` Right ((x `ge` y) `Or` z)
    prec "x >= y or z" `shouldBe` Right ((x `ge` y) `orOp` z)
    prec "x >= y xor z" `shouldBe` Right ((x `ge` y) `xorOp` z)
    prec "x >= y and z" `shouldBe` Right ((x `ge` y) `andOp` z)
    prec "x >= y == z" `shouldBe` Right ((x `ge` y) `eq` z)
    prec "x >= y != z" `shouldBe` Right ((x `ge` y) `ne` z)
    prec "x >= y < z" `shouldBe` Right ((x `ge` y) `lt` z)
    prec "x >= y <= z" `shouldBe` Right ((x `ge` y) `le` z)
    prec "x >= y > z" `shouldBe` Right ((x `ge` y) `gt` z)
    prec "x >= y >= z" `shouldBe` Right ((x `ge` y) `ge` z)
    prec "x >= y :: z" `shouldBe` Right (x `ge` (y `cons` z))
    prec "x >= y : z" `shouldBe` Right (x `ge` (y `Ann` z))
    prec "x >= y -> z" `shouldBe` Right (x `ge` (y `Fun` z))
    prec "x >= @y. z" `shouldBe` Right (x `ge` For ["y"] z)
    prec "x >= y + z" `shouldBe` Right (x `ge` (y `add` z))
    prec "x >= y - z" `shouldBe` Right (x `ge` (y `sub` z))
    prec "x >= y * z" `shouldBe` Right (x `ge` (y `mul` z))
    prec "x >= y / z" `shouldBe` Right (x `ge` (y `div'` z))
    prec "x >= y // z" `shouldBe` Right (x `ge` (y `div2` z))
    prec "x >= y ^ z" `shouldBe` Right (x `ge` (y `pow` z))
    prec "x >= -y" `shouldBe` Right (x `ge` neg y)
    prec "x >= y(z)" `shouldBe` Right (x `ge` (y `app1` z))

  it "☯ TaoPrecedence.Fun" $ do
    prec "x -> y | z" `shouldBe` Right ((x `Fun` y) `Or` z)
    prec "x -> y or z" `shouldBe` Right ((x `Fun` y) `orOp` z)
    prec "x -> y xor z" `shouldBe` Right ((x `Fun` y) `xorOp` z)
    prec "x -> y and z" `shouldBe` Right ((x `Fun` y) `andOp` z)
    prec "x -> y == z" `shouldBe` Right ((x `Fun` y) `eq` z)
    prec "x -> y != z" `shouldBe` Right ((x `Fun` y) `ne` z)
    prec "x -> y < z" `shouldBe` Right ((x `Fun` y) `lt` z)
    prec "x -> y <= z" `shouldBe` Right ((x `Fun` y) `le` z)
    prec "x -> y > z" `shouldBe` Right ((x `Fun` y) `gt` z)
    prec "x -> y >= z" `shouldBe` Right ((x `Fun` y) `ge` z)
    prec "x -> y : z" `shouldBe` Right ((x `Fun` y) `Ann` z)
    prec "x -> y -> z" `shouldBe` Right (x `Fun` (y `Fun` z))
    prec "x -> y :: z" `shouldBe` Right (x `Fun` (y `cons` z))
    prec "x -> @y. z" `shouldBe` Right (x `Fun` For ["y"] z)
    prec "x -> y + z" `shouldBe` Right (x `Fun` (y `add` z))
    prec "x -> y - z" `shouldBe` Right (x `Fun` (y `sub` z))
    prec "x -> y * z" `shouldBe` Right (x `Fun` (y `mul` z))
    prec "x -> y / z" `shouldBe` Right (x `Fun` (y `div'` z))
    prec "x -> y // z" `shouldBe` Right (x `Fun` (y `div2` z))
    prec "x -> y ^ z" `shouldBe` Right (x `Fun` (y `pow` z))
    prec "x -> -y" `shouldBe` Right (x `Fun` neg y)
    prec "x -> y(z)" `shouldBe` Right (x `Fun` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Cons" $ do
    prec "x :: y | z" `shouldBe` Right ((x `cons` y) `Or` z)
    prec "x :: y or z" `shouldBe` Right ((x `cons` y) `orOp` z)
    prec "x :: y xor z" `shouldBe` Right ((x `cons` y) `xorOp` z)
    prec "x :: y and z" `shouldBe` Right ((x `cons` y) `andOp` z)
    prec "x :: y == z" `shouldBe` Right ((x `cons` y) `eq` z)
    prec "x :: y != z" `shouldBe` Right ((x `cons` y) `ne` z)
    prec "x :: y < z" `shouldBe` Right ((x `cons` y) `lt` z)
    prec "x :: y <= z" `shouldBe` Right ((x `cons` y) `le` z)
    prec "x :: y > z" `shouldBe` Right ((x `cons` y) `gt` z)
    prec "x :: y >= z" `shouldBe` Right ((x `cons` y) `ge` z)
    prec "x :: y : z" `shouldBe` Right ((x `cons` y) `Ann` z)
    prec "x :: y -> z" `shouldBe` Right ((x `cons` y) `Fun` z)
    prec "x :: y :: z" `shouldBe` Right (x `cons` (y `cons` z))
    prec "x :: (@y. z)" `shouldBe` Right (x `cons` For ["y"] z)
    prec "x :: y + z" `shouldBe` Right (x `cons` (y `add` z))
    prec "x :: y - z" `shouldBe` Right (x `cons` (y `sub` z))
    prec "x :: y * z" `shouldBe` Right (x `cons` (y `mul` z))
    prec "x :: y / z" `shouldBe` Right (x `cons` (y `div'` z))
    prec "x :: y // z" `shouldBe` Right (x `cons` (y `div2` z))
    prec "x :: y ^ z" `shouldBe` Right (x `cons` (y `pow` z))
    prec "x :: -y" `shouldBe` Right (x `cons` neg y)
    prec "x :: y(z)" `shouldBe` Right (x `cons` (y `app1` z))

  it "☯ TaoPrecedence.Ann" $ do
    prec "x : y | z" `shouldBe` Right ((x `Ann` y) `Or` z)
    prec "x : y or z" `shouldBe` Right ((x `Ann` y) `orOp` z)
    prec "x : y xor z" `shouldBe` Right ((x `Ann` y) `xorOp` z)
    prec "x : y and z" `shouldBe` Right ((x `Ann` y) `andOp` z)
    prec "x : y == z" `shouldBe` Right ((x `Ann` y) `eq` z)
    prec "x : y != z" `shouldBe` Right ((x `Ann` y) `ne` z)
    prec "x : y < z" `shouldBe` Right ((x `Ann` y) `lt` z)
    prec "x : y <= z" `shouldBe` Right ((x `Ann` y) `le` z)
    prec "x : y > z" `shouldBe` Right ((x `Ann` y) `gt` z)
    prec "x : y >= z" `shouldBe` Right ((x `Ann` y) `ge` z)
    prec "x : y : z" `shouldBe` Right (x `Ann` (y `Ann` z))
    prec "x : y -> z" `shouldBe` Right (x `Ann` (y `Fun` z))
    prec "x : y :: z" `shouldBe` Right (x `Ann` (y `cons` z))
    prec "x : @y. z" `shouldBe` Right (x `Ann` For ["y"] z)
    prec "x : y + z" `shouldBe` Right (x `Ann` (y `add` z))
    prec "x : y - z" `shouldBe` Right (x `Ann` (y `sub` z))
    prec "x : y * z" `shouldBe` Right (x `Ann` (y `mul` z))
    prec "x : y / z" `shouldBe` Right (x `Ann` (y `div'` z))
    prec "x : y // z" `shouldBe` Right (x `Ann` (y `div2` z))
    prec "x : y ^ z" `shouldBe` Right (x `Ann` (y `pow` z))
    prec "x : -y" `shouldBe` Right (x `Ann` neg y)
    prec "x : y(z)" `shouldBe` Right (x `Ann` (y `app1` z))

  it "☯ TaoPrecedence.For" $ do
    prec "@x. y | z" `shouldBe` Right (For ["x"] y `Or` z)
    prec "@x. y or z" `shouldBe` Right (For ["x"] y `orOp` z)
    prec "@x. y xor z" `shouldBe` Right (For ["x"] y `xorOp` z)
    prec "@x. y and z" `shouldBe` Right (For ["x"] y `andOp` z)
    prec "@x. y == z" `shouldBe` Right (For ["x"] y `eq` z)
    prec "@x. y != z" `shouldBe` Right (For ["x"] y `ne` z)
    prec "@x. y < z" `shouldBe` Right (For ["x"] y `lt` z)
    prec "@x. y <= z" `shouldBe` Right (For ["x"] y `le` z)
    prec "@x. y > z" `shouldBe` Right (For ["x"] y `gt` z)
    prec "@x. y >= z" `shouldBe` Right (For ["x"] y `ge` z)
    prec "@x. y : z" `shouldBe` Right (For ["x"] y `Ann` z)
    prec "@x. y -> z" `shouldBe` Right (For ["x"] (y `Fun` z))
    prec "@x. y :: z" `shouldBe` Right (For ["x"] (y `cons` z))
    prec "@x. @y. z" `shouldBe` Right (For ["x"] (For ["y"] z))
    prec "@x. y + z" `shouldBe` Right (For ["x"] (y `add` z))
    prec "@x. y - z" `shouldBe` Right (For ["x"] (y `sub` z))
    prec "@x. y * z" `shouldBe` Right (For ["x"] (y `mul` z))
    prec "@x. y / z" `shouldBe` Right (For ["x"] (y `div'` z))
    prec "@x. y // z" `shouldBe` Right (For ["x"] (y `div2` z))
    prec "@x. y ^ z" `shouldBe` Right (For ["x"] (y `pow` z))
    prec "@x. -y" `shouldBe` Right (For ["x"] (neg y))
    prec "@x. y(z)" `shouldBe` Right (For ["x"] (app1 y z))

  it "☯ TaoPrecedence.Op2.Add" $ do
    prec "x + y | z" `shouldBe` Right ((x `add` y) `Or` z)
    prec "x + y or z" `shouldBe` Right ((x `add` y) `orOp` z)
    prec "x + y xor z" `shouldBe` Right ((x `add` y) `xorOp` z)
    prec "x + y and z" `shouldBe` Right ((x `add` y) `andOp` z)
    prec "x + y == z" `shouldBe` Right ((x `add` y) `eq` z)
    prec "x + y != z" `shouldBe` Right ((x `add` y) `ne` z)
    prec "x + y < z" `shouldBe` Right ((x `add` y) `lt` z)
    prec "x + y <= z" `shouldBe` Right ((x `add` y) `le` z)
    prec "x + y > z" `shouldBe` Right ((x `add` y) `gt` z)
    prec "x + y >= z" `shouldBe` Right ((x `add` y) `ge` z)
    prec "x + y :: z" `shouldBe` Right ((x `add` y) `cons` z)
    prec "x + y : z" `shouldBe` Right ((x `add` y) `Ann` z)
    prec "x + y -> z" `shouldBe` Right ((x `add` y) `Fun` z)
    prec "x + (@y. z)" `shouldBe` Right (x `add` For ["y"] z)
    prec "x + y + z" `shouldBe` Right ((x `add` y) `add` z)
    prec "x + y - z" `shouldBe` Right ((x `add` y) `sub` z)
    prec "x + y * z" `shouldBe` Right (x `add` (y `mul` z))
    prec "x + y / z" `shouldBe` Right (x `add` (y `div'` z))
    prec "x + y // z" `shouldBe` Right (x `add` (y `div2` z))
    prec "x + y ^ z" `shouldBe` Right (x `add` (y `pow` z))
    prec "x + -y" `shouldBe` Right (x `add` neg y)
    prec "x + y(z)" `shouldBe` Right (x `add` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Sub" $ do
    prec "x - y | z" `shouldBe` Right ((x `sub` y) `Or` z)
    prec "x - y or z" `shouldBe` Right ((x `sub` y) `orOp` z)
    prec "x - y xor z" `shouldBe` Right ((x `sub` y) `xorOp` z)
    prec "x - y and z" `shouldBe` Right ((x `sub` y) `andOp` z)
    prec "x - y == z" `shouldBe` Right ((x `sub` y) `eq` z)
    prec "x - y != z" `shouldBe` Right ((x `sub` y) `ne` z)
    prec "x - y < z" `shouldBe` Right ((x `sub` y) `lt` z)
    prec "x - y <= z" `shouldBe` Right ((x `sub` y) `le` z)
    prec "x - y > z" `shouldBe` Right ((x `sub` y) `gt` z)
    prec "x - y >= z" `shouldBe` Right ((x `sub` y) `ge` z)
    prec "x - y :: z" `shouldBe` Right ((x `sub` y) `cons` z)
    prec "x - y : z" `shouldBe` Right ((x `sub` y) `Ann` z)
    prec "x - y -> z" `shouldBe` Right ((x `sub` y) `Fun` z)
    prec "x - (@y. z)" `shouldBe` Right (x `sub` For ["y"] z)
    prec "x - y + z" `shouldBe` Right ((x `sub` y) `add` z)
    prec "x - y - z" `shouldBe` Right ((x `sub` y) `sub` z)
    prec "x - y * z" `shouldBe` Right (x `sub` (y `mul` z))
    prec "x - y / z" `shouldBe` Right (x `sub` (y `div'` z))
    prec "x - y // z" `shouldBe` Right (x `sub` (y `div2` z))
    prec "x - y ^ z" `shouldBe` Right (x `sub` (y `pow` z))
    prec "x - -y" `shouldBe` Right (x `sub` neg y)
    prec "x - y(z)" `shouldBe` Right (x `sub` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Mul" $ do
    prec "x * y | z" `shouldBe` Right ((x `mul` y) `Or` z)
    prec "x * y or z" `shouldBe` Right ((x `mul` y) `orOp` z)
    prec "x * y xor z" `shouldBe` Right ((x `mul` y) `xorOp` z)
    prec "x * y and z" `shouldBe` Right ((x `mul` y) `andOp` z)
    prec "x * y == z" `shouldBe` Right ((x `mul` y) `eq` z)
    prec "x * y != z" `shouldBe` Right ((x `mul` y) `ne` z)
    prec "x * y < z" `shouldBe` Right ((x `mul` y) `lt` z)
    prec "x * y <= z" `shouldBe` Right ((x `mul` y) `le` z)
    prec "x * y > z" `shouldBe` Right ((x `mul` y) `gt` z)
    prec "x * y >= z" `shouldBe` Right ((x `mul` y) `ge` z)
    prec "x * y :: z" `shouldBe` Right ((x `mul` y) `cons` z)
    prec "x * y : z" `shouldBe` Right ((x `mul` y) `Ann` z)
    prec "x * y -> z" `shouldBe` Right ((x `mul` y) `Fun` z)
    prec "x * (@y. z)" `shouldBe` Right (x `mul` For ["y"] z)
    prec "x * y + z" `shouldBe` Right ((x `mul` y) `add` z)
    prec "x * y - z" `shouldBe` Right ((x `mul` y) `sub` z)
    prec "x * y * z" `shouldBe` Right ((x `mul` y) `mul` z)
    prec "x * y / z" `shouldBe` Right ((x `mul` y) `div'` z)
    prec "x * y // z" `shouldBe` Right ((x `mul` y) `div2` z)
    prec "x * y ^ z" `shouldBe` Right (x `mul` (y `pow` z))
    prec "x * -y" `shouldBe` Right (x `mul` neg y)
    prec "x * y(z)" `shouldBe` Right (x `mul` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Div" $ do
    prec "x / y | z" `shouldBe` Right (x `div'` y `Or` z)
    prec "x / y or z" `shouldBe` Right ((x `div'` y) `orOp` z)
    prec "x / y xor z" `shouldBe` Right ((x `div'` y) `xorOp` z)
    prec "x / y and z" `shouldBe` Right ((x `div'` y) `andOp` z)
    prec "x / y == z" `shouldBe` Right (x `div'` y `eq` z)
    prec "x / y != z" `shouldBe` Right (x `div'` y `ne` z)
    prec "x / y < z" `shouldBe` Right (x `div'` y `lt` z)
    prec "x / y <= z" `shouldBe` Right (x `div'` y `le` z)
    prec "x / y > z" `shouldBe` Right (x `div'` y `gt` z)
    prec "x / y >= z" `shouldBe` Right (x `div'` y `ge` z)
    prec "x / y :: z" `shouldBe` Right (x `div'` y `cons` z)
    prec "x / y : z" `shouldBe` Right (x `div'` y `Ann` z)
    prec "x / y -> z" `shouldBe` Right (x `div'` y `Fun` z)
    prec "x / (@y. z)" `shouldBe` Right (x `div'` For ["y"] z)
    prec "x / y + z" `shouldBe` Right (x `div'` y `add` z)
    prec "x / y - z" `shouldBe` Right (x `div'` y `sub` z)
    prec "x / y * z" `shouldBe` Right (x `div'` y `mul` z)
    prec "x / y / z" `shouldBe` Right (x `div'` y `div'` z)
    prec "x / y // z" `shouldBe` Right (x `div'` y `div2` z)
    prec "x / y ^ z" `shouldBe` Right (x `div'` (y `pow` z))
    prec "x / -y" `shouldBe` Right (x `div'` neg y)
    prec "x / y(z)" `shouldBe` Right (x `div'` (y `app1` z))

  it "☯ TaoPrecedence.Op2.DivI" $ do
    prec "x // y | z" `shouldBe` Right ((x `div2` y) `Or` z)
    prec "x // y or z" `shouldBe` Right ((x `div2` y) `orOp` z)
    prec "x // y xor z" `shouldBe` Right ((x `div2` y) `xorOp` z)
    prec "x // y and z" `shouldBe` Right ((x `div2` y) `andOp` z)
    prec "x // y == z" `shouldBe` Right ((x `div2` y) `eq` z)
    prec "x // y != z" `shouldBe` Right ((x `div2` y) `ne` z)
    prec "x // y < z" `shouldBe` Right ((x `div2` y) `lt` z)
    prec "x // y <= z" `shouldBe` Right ((x `div2` y) `le` z)
    prec "x // y > z" `shouldBe` Right ((x `div2` y) `gt` z)
    prec "x // y >= z" `shouldBe` Right ((x `div2` y) `ge` z)
    prec "x // y :: z" `shouldBe` Right ((x `div2` y) `cons` z)
    prec "x // y : z" `shouldBe` Right ((x `div2` y) `Ann` z)
    prec "x // y -> z" `shouldBe` Right ((x `div2` y) `Fun` z)
    prec "x // (@y. z)" `shouldBe` Right (x `div2` For ["y"] z)
    prec "x // y + z" `shouldBe` Right ((x `div2` y) `add` z)
    prec "x // y - z" `shouldBe` Right ((x `div2` y) `sub` z)
    prec "x // y * z" `shouldBe` Right ((x `div2` y) `mul` z)
    prec "x // y / z" `shouldBe` Right ((x `div2` y) `div'` z)
    prec "x // y // z" `shouldBe` Right ((x `div2` y) `div2` z)
    prec "x // y ^ z" `shouldBe` Right (x `div2` (y `pow` z))
    prec "x // -y" `shouldBe` Right (x `div2` neg y)
    prec "x // y(z)" `shouldBe` Right (x `div2` (y `app1` z))

  it "☯ TaoPrecedence.Op2.Pow" $ do
    prec "x ^ y | z" `shouldBe` Right ((x `pow` y) `Or` z)
    prec "x ^ y or z" `shouldBe` Right ((x `pow` y) `orOp` z)
    prec "x ^ y xor z" `shouldBe` Right ((x `pow` y) `xorOp` z)
    prec "x ^ y and z" `shouldBe` Right ((x `pow` y) `andOp` z)
    prec "x ^ y == z" `shouldBe` Right ((x `pow` y) `eq` z)
    prec "x ^ y != z" `shouldBe` Right ((x `pow` y) `ne` z)
    prec "x ^ y < z" `shouldBe` Right ((x `pow` y) `lt` z)
    prec "x ^ y <= z" `shouldBe` Right ((x `pow` y) `le` z)
    prec "x ^ y > z" `shouldBe` Right ((x `pow` y) `gt` z)
    prec "x ^ y >= z" `shouldBe` Right ((x `pow` y) `ge` z)
    prec "x ^ y :: z" `shouldBe` Right ((x `pow` y) `cons` z)
    prec "x ^ y : z" `shouldBe` Right ((x `pow` y) `Ann` z)
    prec "x ^ y -> z" `shouldBe` Right ((x `pow` y) `Fun` z)
    prec "x ^ (@y. z)" `shouldBe` Right (x `pow` For ["y"] z)
    prec "x ^ y + z" `shouldBe` Right ((x `pow` y) `add` z)
    prec "x ^ y - z" `shouldBe` Right ((x `pow` y) `sub` z)
    prec "x ^ y * z" `shouldBe` Right ((x `pow` y) `mul` z)
    prec "x ^ y / z" `shouldBe` Right ((x `pow` y) `div'` z)
    prec "x ^ y // z" `shouldBe` Right ((x `pow` y) `div2` z)
    prec "x ^ y ^ z" `shouldBe` Right (x `pow` (y `pow` z))
    prec "x ^ -y" `shouldBe` Right (x `pow` neg y)
    prec "x ^ y(z)" `shouldBe` Right (x `pow` (y `app1` z))

  it "☯ TaoPrecedence.Op1.Neg" $ do
    prec "-x | y" `shouldBe` Right (neg x `Or` y)
    prec "-x or y" `shouldBe` Right (neg x `orOp` y)
    prec "-x xor y" `shouldBe` Right (neg x `xorOp` y)
    prec "-x and y" `shouldBe` Right (neg x `andOp` y)
    prec "-x == y" `shouldBe` Right (neg x `eq` y)
    prec "-x != y" `shouldBe` Right (neg x `ne` y)
    prec "-x < y" `shouldBe` Right (neg x `lt` y)
    prec "-x <= y" `shouldBe` Right (neg x `le` y)
    prec "-x > y" `shouldBe` Right (neg x `gt` y)
    prec "-x >= y" `shouldBe` Right (neg x `ge` y)
    prec "-x :: y" `shouldBe` Right (neg x `cons` y)
    prec "-x : y" `shouldBe` Right (neg x `Ann` y)
    prec "-x -> y" `shouldBe` Right (neg x `Fun` y)
    prec "-(@x. y)" `shouldBe` Right (neg (For ["x"] y))
    prec "-x + y" `shouldBe` Right (neg x `add` y)
    prec "-x - y" `shouldBe` Right (neg x `sub` y)
    prec "-x * y" `shouldBe` Right (neg x `mul` y)
    prec "-x / y" `shouldBe` Right (neg x `div'` y)
    prec "-x // y" `shouldBe` Right (neg x `div2` y)
    prec "-x ^ y" `shouldBe` Right (neg x `pow` y)
    prec "-x(y)" `shouldBe` Right (neg x `app1` y)

  it "☯ TaoPrecedence.App" $ do
    prec "x(y) | z" `shouldBe` Right ((x `app1` y) `Or` z)
    prec "x(y) or z" `shouldBe` Right ((x `app1` y) `orOp` z)
    prec "x(y) xor z" `shouldBe` Right ((x `app1` y) `xorOp` z)
    prec "x(y) and z" `shouldBe` Right ((x `app1` y) `andOp` z)
    prec "x(y) == z" `shouldBe` Right ((x `app1` y) `eq` z)
    prec "x(y) != z" `shouldBe` Right ((x `app1` y) `ne` z)
    prec "x(y) < z" `shouldBe` Right ((x `app1` y) `lt` z)
    prec "x(y) <= z" `shouldBe` Right ((x `app1` y) `le` z)
    prec "x(y) > z" `shouldBe` Right ((x `app1` y) `gt` z)
    prec "x(y) >= z" `shouldBe` Right ((x `app1` y) `ge` z)
    prec "x(y) :: z" `shouldBe` Right ((x `app1` y) `cons` z)
    prec "x(y) : z" `shouldBe` Right ((x `app1` y) `Ann` z)
    prec "x(y) -> z" `shouldBe` Right ((x `app1` y) `Fun` z)
    prec "x(@y. z)" `shouldBe` Right (x `app1` For ["y"] z)
    prec "x(y) + z" `shouldBe` Right ((x `app1` y) `add` z)
    prec "x(y) - z" `shouldBe` Right ((x `app1` y) `sub` z)
    prec "x(y) * z" `shouldBe` Right ((x `app1` y) `mul` z)
    prec "x(y) / z" `shouldBe` Right ((x `app1` y) `div'` z)
    prec "x(y) // z" `shouldBe` Right ((x `app1` y) `div2` z)
    prec "x(y) ^ z" `shouldBe` Right ((x `app1` y) `pow` z)
    prec "x(y)(z)" `shouldBe` Right ((x `app1` y) `app1` z)

-- Metadata.TrailingComment
